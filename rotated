#!/usr/bin/env perl

use Getopt::Long;
use bytes;
my $outfile = "";
my $size = "100M";
my $keep = 20;

GetOptions(
  "out=s" => \$outfile,
  "size:s" => \$size,
  "keep:i" => \$keep
);

if($outfile eq "") {
  die "-out <outfile> is required";
}

my $size_limit = &calc_size($size);
if($size_limit <= 0) {
  die "-size <bytes> must be positive!";
}

if($keep <= 0) {
  die "-keep <files_to_keep> must be positive";
}

binmode STDIN;
open FH, ">>$outfile" or die "Can't open $outfile for writing";
binmode FH;
my $last_check = time;
my $bytes_written = -s $outfile;
&pipe;

sub rotate_files {
  my $count = 0;
  for(my $i = $keep - 1; $i > 0; $i--) {
    my $current_file = "$outfile.$i";
    my $next_file = "$outfile." . ($i + 1);
    if(-e "$current_file") {
      rename($current_file, $next_file) or die "Rename failed $current_file -> $next_file";
    }
  }
  rename($outfile, "$outfile.1") or die "Can't rename $outfile to $outfile.1";
}
sub check_rotate {
  if($bytes_written >= $size_limit) {
    close FH;
    &rotate_files;
    open FH, ">>$outfile" or die "Can't open $outfile for writing";
    binmode FH;
    $bytes_written = 0;
  }
}

sub pipe {
  while(1) {
    #FILEHANDLE,SCALAR,LENGTH
    my $buffer = <STDIN>;
    if(not defined $buffer) {
      last;
    }
    &check_rotate;
    my $length = length($buffer);
    print FH $buffer;
    $bytes_written = $bytes_written + $length;
    &check_rotate;
  }
  close FH;
}



sub calc_size($) {
  my $unit_lookup = {
    "k" => 1000,
    "K" => 1024,
    "m" => 1000000,
    "M" => 1048576,
    "g" => 1000000000,
    "G" => 1073741824,
    "kB" => 1000,
    "KB" => 1024,
    "KiB" => 1024,
    "mB" => 1000000,
    "MB" => 1048576,
    "MiB" => 1048576,
    "gB" => 1000000000,
    "GB" => 1073741824,
    "GiB" => 1073741824
  };
  my $arg = shift;
  if(not $arg =~ m/^([\d_,]+)(\D+)?$/) {
    die "Not valid size: $arg. Expect a valid size notation e.g. '10K', '100000', '30g', '1,000,000', '4_000_000k'";
  }

  my $count = $1;
  my $unit = $2;
  $count =~ s/[_,]//g;
  if(not $unit) {
    return $count;
  } else {
    my $lookup = $unit_lookup->{$unit};
    if(not $lookup) {
      die "Invalid unit $unit. Only support " . join(",", keys(%$unit_lookup)) . "\n";
    }
    return $count * $lookup;
  }
}

sub fgets {
    my($fh, $limit) = @_;

    my($char, $str);
    for(1..$limit) {
        my $char = getc $fh;
        print $char;
        last unless defined $char;
        $str .= $char;
        last if $char eq "\n";
    }

    return $str;
}
